-------- 5.4 --------
React apps are entirely made out of components.
A component has its own data, logic, and appearance (how it works and looks)

-------- 5.5 --------
Nesting components means calling (including) them from the other components. But we never nest function declarations inside each other. We always declare all our components in the top level

-------- 5.6 --------
JSX:
Declarative syntax to describe what components look like and how they work
In practice it means that each component must return one block of JSX.
JSX is is an extension of JavaScript which allows us to combine parts of HTML, CSS and JavaScript all into one block of code.
Each JSX element is converted to a React.createElement function call by Babel. So we could use React without JSX, but that just looks ugly and it's hard to read.

JSX is declarative. It means that we basically describe what UI should look like, based on current data. In contrast, vanilla JS is imperative, and there we manually select DOM elements and traverse the DOM. And we mutate DOM step-by-step.
React is an abstraction away from DOM: we never touch the DOM. Instead, we think of the UI as a reflection of the current data.
Imperative: HOW to do things.
Declarative: WHAT we want.

-------- 5.9 --------
Separation of Concerns
Before the rise of SPAs (single-page applications) we basically had one technology per file. So that was the "Traditional" separation of concerns.
But then JS became more in charge of HTML. Logic and UI are tightly coupled, so why keep them separated? => React components + JSX
So content and logic are tightly coupled together and so it makes sense that they are co-located here. And co-located simply means that things that change together should be located as close as possible together. And in the case of React apps, that means that instead of one technology per file, we have one component per file.

-------- 5.10 --------
WRONG:
<footer class="footer">

RIGHT:
<footer className="footer">

-------- 5.12 --------
Props are used to pass data from parent components to child components (down the component tree).
With props, parent components control how child components look and work.
Anything can be passed as props: we can pass single values, arrays, objects, functions and even other React components.
Component's data consists of props and state. State is basically internal component data that can be updated by the component's logic (by the component itself). And props is data coming from the outside, it can only be updated by the parent component.
Props are immutable. They're read only.
If you need to mutate props, you actually need state.
That's because mutating props would affect parent, creating side effects.
And React is all about pure functions without side-effects.
In general in React a component should never mutate any data that we write outside of its function scope.
React uses one-way data flow. So data can flow from parents to children, but never the opposite way.

-------- 5.14 --------
JSX works essentially just like HTML. However, we can enter a JavaScript mode by using curly braces anywhere in the markup where a value like text or an attribute is expected.
We can place JS expressions inside {}. For example: reference variables, arrays, objects, [].map(), ternary operator.
Statements are not allowed (if / else, for, switch).
JSX produces a JS expression. 
We can place other pieces of JSX inside {}.
We can write JSX anywhere inside a component (in if / else, assign to variables, pass it into functions).
JSX can only have one root element. If you need more, use <React.Fragment> (see below, in 5.21)
DIFFERENCES BETWEEN JSX AND SHTML
- className instead of HTML's class
- htmlFor instead of HTML's for
- Every tag needs to be closed. Examples: <img /> or <br />
- All event handlers and other properties need to be camelCased. Examples: onClick or onMouseOver
- Exception: aria-* and data-* are written with dashes like in HTML
- CSS inline styles are written like this: {{<style>}} (to reference a variable, and then an object)
- CSS property names are also camelCased
- Comments need to be in {} (because they are JS)

-------- 5.20 --------
function Order({ closeHour, openHour }) {
  return (
      <p>
        We're open from {openHour}:00 to {closeHour}:00. Come visit us or order
        online.
      </p>
  );
}

is basically a short version of 

function Order(props) {
  return (
      <p>
        We're open from {props.openHour}:00 to {props.closeHour}:00. Come visit us or order
        online.
      </p>
  );
}
It uses destructuring.

-------- 5.21 --------
React Fragment is this element: <></> or, the longer version, that allows to include a key: <React.Fragment key="somKeyHere"></React.Fragment>. You can wrap several elements into it and then the function will return several html nodes as if they have no wrapper at all. So basically it enables us to return several elements from a component.

-------- 6.3 --------
onClick={() => alert("previous")}
Here inside of {} should be a function, not a function call. Otherwise it'll be called immediately as the page loads.
So, for example, it should be like this: onClick={handlePrevious} or this: onClick={() => alert("next")}
Neither this: onClick={handlePrevious()} nor this: onClick={alert("next")}

Event handler functions can be written inside of a function declaring the component, like this:
export default function App() {
  function handlePrevious() {}

  return (...);
}

-------- 6.4 --------
So state is basically data that a component can hold over time, and we use it for information that the component needs to remember throughout its lifecycle. Therefore, we can think of state as being the memory of a component.
Some examples: notification count, text content of an input field or the active tab in a tabbed component. It can also be a bit more complex data, for example, the content of a shopping cart.
"State variable" or a "piece of state" is a single variable in a component (component state).
And "state" is like the entire condition of the component at a certain point in time.
So, state === all pieces of state together.

Updating component state triggers React to re-render the component, so to create a new Component View.
Component View is basically just the component visually rendered on the screen.
State allows developers to: 
Update the component's view by rerendering the component.
Persist local variables between multiple renders and rerenders.

-------- 6.5 --------
const [step, setStep] = useState(1);
useState returns an array with two things:
[0] step - is a variable
[1] setStep - function to update step
1 - default value that is assigned to [0] step

useState function is a hook. Hooks start with "use" keyword.
We can only call hooks like use state on the top level of the function.

We should really only update state using setter function. So not manually.

-------- 6.7 --------
A component is re-rendered when its state is updated.
We change state -> React re-renders component -> View will be replace with a new one.
So to update the view we need to update the state.
React is called this way because it reacts to state changes by re-rendering the UI.

-------- 6.10 --------
WRONG and won't work twice:
setStep(step + 1);
setStep(step + 1);

RIGHT, works as expected:
setStep((s) => s + 1);
setStep((s) => s + 1);

We need to do this when we update the state by using the current value of the state.

-------- 6.11 --------
Each component has and manages its own state, no matter how many times we render the same component. So, for example, if we have several <Item /><Item /><Item /> on the page, each of them will have its own state that won't affect the state of others. The entire UI is always a representation of all the current states in all components. A React application is fundamentally all about changing state over time and of course also correctly displaying that state at all times.

PRACTICAL GUIDELINES ABOUT STATE

Use a state variable for any data that the component should keep track of ("remember") over
time. This is data that will change at some point. In Vanilla JS, that's a let variable, or an [] or {}

Whenever you want something in the component to be dynamic, create a piece of state related
to that "thing", and update the state when the "thing" should change (aka "be dynamic")
Example: A modal window can be open or closed. So we create a state variable
isOpen that tracks whether the modal is open or not. On isOpen = true we
display the window, on isOpen = false we hide it.

If you want to change the way a component looks, or the data it displays, update its state.
This usually happens in an event handler function.

When building a component, imagine its view as a reflection of state changing over time

For data that should not trigger component re-renders, don't use state. Use a regular variable
instead. This is a common beginner mistake.

-------- 6.19 --------
State is internal data. So data that is owned by the component in which it is declared. State can be thought of as the components memory because it can hold data over time. State can be updated by the component itself. This will then cause the component to be rerendered by react.


Props is external data. So data that is owned by the parent component and you can think of props as function parameters, as a communication channel between parent and child components where parents can pass data into children. When the child component receives new updated props that will actually also cause the component to rerender.

So in conclusion, whenever a piece of state is passed as a prop, when that state updates, both components are re-rendered.

STATE                                   PROPS

Internal data, owned by          External data, owned by
component                        parent component

Component "memory"               Similar to function                       
                                 parameters

Can be updated by the            Read-only
component itself

Updating state causes            Receiving new props causes
component to re-render           component to re-render.
                                 Usually when the parent's
                                 state has been updated


Used to make components          Used by parent to configure
interactive                      child component ("settings")

-------- 7.3 --------
State management: Deciding when to create pieces of
state, what types of state are necessary, where to place
each piece of state, and how data flows through the app.

LOCAL STATE

- State needed only by one or few components
- State that is defined in a component and only
that component and child components have
access to it (by passing via props)

GLOBAL STATE

- State that many components might need
- Shared state that is accessible to every
component in the entire application

-------- 7.5 --------
We can call the technique of passing down a setter function "child to parent communication" or also "inverse data flow". Inverse, because usually data only flows down. But here we have a trick that allows us to basically have the data flowing up as well.

-------- 8.6 --------
The basic attachment of input:
function Input() {
  const [name, setName] = useState();
  
  return (
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
  );
}

-------- 10.3 --------
A component that is too large does too many things and has too many responsibilities. It receives too many props (> 10). The're hard to reuse. The code is very complex.
Components that are too small create a confusing codebase with hundreds of mini-components. The codebase would be too abstracted.
The 4 criteria for splitting a UI into components:
  1. Logical separation of content/layout
  2. Reusability
  3. Responsibilities / complexity
  4. Personal coding style

When to create a new component?
Start with a big component and split it into smaller ones when it becomes necessary.
You might need a new component if:
- The component contains pieces of content or layout that don't belong together.
- It's possible to reuse part of the component
- You want / need to reuse part of a component
- The component is doing too many different things
- The component relies on too many props
- The component has too many pieces of state and/or effects?
- The code, including JSX, is too complex/confusing
- You prefer smaller functions / components

! Be aware that creating a new component creates a new abstraction. Abstractions have a cost, because more abstractions require more mental  energy to switch back and forth between components. So try not to create new components too early.
! Name a component according to what it does or what it displays. Don't be afraid of using long component names
! Never declare a new component inside another component!
! Co-locate related components inside the same file. Don't separate components into different files too early
! It's completely normal that an app has components of many different sizes, including very small and huge ones

The smaller components are - the more reusable they are.

-------- 10.5 --------
Most of the components in React fall into one of three categories:
- Stateless / presentational components
    These don't have any state. They get some props and then simply present the data & other content. The're usually small and reusable.
- Stateful components
    They have state. Can be reusable.
- Structural components
    "Pages", "layouts" or "screens" of the app. They're the result of composition. They can be huge and non-reusable (but they don't have to).

-------- 10.7 --------
>> Using a component:
    function Modal() {
      return (
        <div className="modal">
          <Success />
        </div>
      )
    }

    function Success() {
      return <p>Well done !</p>;
    }

>> Component composition: 
    function Modal({ children }) {
      return (
        <div className="modal">
          {children}
        </div>
      )
    }

    function Success() {
      return <p>Well done !< /p>;
    }
  It is used like this: 
    <Modal>
      <Success />
    </Modal>

So component composition is combining different components using the children prop (or explicitly defined props)
With component composition, we can:
1. Create highly reusable and flexible components
2. Fix prop drilling (great for layouts)

-------- 10.10 --------
Implicitly passing in the component:
  <Box>
    <MovieList movies={movies} />
  </Box>

  function Box({ children }) { 
    return <div>{ children }</div>
  }

OR

Explicitly passing in the component:

  <Box element={<MovieList movies={movies} />} />
  function Box({ element }) {
    return <div>{ element }</div>
  }

They both work the same, but with explicit passing you can give the element different names and place them in different places of your code.

-------- 10.14 --------
Every component is created by someone and consumed by someone.
In a way, we can think of components' props as public API of the component

Having too little props:
 - Not flexible enough
 - Might not be useful

Having too many props:
 - Too hard to use
 - Exposing too much complexity
 - Hard-to-write code
 - If you have to do this, provide good default values

We need to find the right balance between too little and too many props, that works for both the consumer and the creator.

-------- 11.03 --------
Component:
  - Description of a piece of UI
  - A component is a function that returns React elements (element tree), usually written as JSX
  - "Blueprint" or "Template"

Component instance:
  - Instances are created when we "use" components
  - React internally calls the component as many times as needed
  - Actual "physical" manifestation of a component
  - Has its own state and props
  - Has a lifecycle (can "be born", "live", and "die")
  - Returns a React element

React element:
  - JSX is converted to React.createElement() function calls
  - A React element is the result of these function calls
  - Basically a big immutable JS object that React keeps in memory
  - Information necessary to create DOM elements
  - Then it's inserted to DOM as a DOM Element (HTML)

DOM Element (HTML)
  - Actual visual representation of the component instance in the browser

-------- 11.04 --------
Symbols (JS primitive) cannot be transmitted via JSON. So React uses them in React elements in order to protect us from getting a fake React element from a malware API.
In theory, we can call a component directly, like this:
  SomeComponent()
instead of this:
  <SomeComponent />
But then React won't see it as a component instance, but as a raw React element. The sate will go to the parent element, so basically it will not work as expected. So never do this.

-------- 11.05 --------
Component -> Component instance -> React Element -> DOM Element (HTML) -> User interface on the screen.

1️⃣ Render is triggered (by updating state somewhere)
 ⬇️
2️⃣ Render Phase (React calls component functions and figures out how DOM should be updated)
 ⬇️
3️⃣ Commit Phase (React actually writes to the DOM, updating, inserting, and deleting elements)
 ⬇️
4️⃣ Browser paint

In React, rendering is NOT updating the DOM or displaying elements on the screen. Rendering only happens internally inside React, it does not produce visual changes.
What we traditionally call rendering happens in two phases in React: render + commit phase.

1️⃣ Render is triggered
  THE TWO SITUATIONS THAT TRIGGER RENDERS:
  1. Initial render of the application
  2. State is updated in one or more component instances (re-render)

  - The render process is triggered for the entire application. But that doesn't meant that everything gets recreated in the DOM. It just means that the process of calling the component functions starts.
  - In practice, it looks like React only re-renders the component where the state update happens, but that's not how it works behind the scenes
  - Renders are not triggered immediately, but scheduled for when the JS engine has some "free time". There is also batching of multiple setState calls in event handlers

-------- 11.06 --------
2️⃣ Render Phase (done by React)
  Component instances that triggered re-render
      At the beginning of the render phase, React will go through the entire component tree, take all the component instances that triggered a re-render and actually render them, i.e call the corresponding component functions that we've written in our code.
  ⬇️
  React Elements
      This creates updated React elements which all together make up the so-called "new virtual DOM". It contains the old elements, the updated element and the updated children of the updated element.
  ⬇️
  New Virtual DOM
  ⬇️
  Reconciliation + Diffing with the current so-called Fiber tree as it exists before the state update.
  ⬇️
  Updated Fiber tree
  ⬇️
  List of DOM updates
  ⬇️
  ...

  The Virtual DOM:
    It is a tree of all React elements created from all instances in the component tree. It's cheap and fast to create multiple trees. Basically it's just an object with information about what to create.
    1) Initial render
      Component tree -> React element tree
    2) Re-renders
      Rendering a component will cause all of its child components to be rendered as well (no matter if props changed or not). It is necessary because React doesn't know whether children will be affected.

  React reconciler is called "Fiber".

  What is reconciliation and why do we need it?
  We need it because:
  - Updating the entire DOM is inefficient and wasteful:
    1. Writing to the DOM is (relatively) slow.
    2. Usually only a small part of the DOM needs to be updated.
  - React reuses as much of the existing DOM as possible
    It uses Reconciliation: Deciding which DOM elements actually need to be inserted, deleted, or updated, in order to reflect the latest state changes.

  Reconciliation is processed by a reconciler, and we can say that the reconciler really is the engine of React, the heart of React.

  The reconciler: Fiber.
    The Fiber takes the whole React element tree (virtual DOM) and based on it builds a fiber tree.
    Fiber tree is an internal tree that has a "fiber" for each component instance and DOM element.
    Fibers are NOT re-created on every render. Fiber tree is never destroyed. Instead, it's a mutable data structure. It is created during the initial render and then it mutates over and over again.
    So fibers ("units of work") keep track of things like current component state, props, side effects, used hooks, etc. It also contains queue of work to do.
    Fiber tree doesn't have the usual parent-children structure. It has a structure of a linked list, where each first child has a link to its parent and all the other children that have a link to their previous sibling.
    Fiber tree contains both React components and DOM elements, so it is a complete representation of the entire DOM structure.
    Work can be done asynchronously, so rendering process can be split into chinks, tasks can be prioritized, and work can be paused, reused, or thrown away. 
      - It enables concurrent features like Suspense or transitions. 
      - Long renders won't block JS engine.
  Reconciliation in action.
    Whenever reconciliation needs to happen, fiber walks through the entire tree step by step and analyzes what needs to change between the current fiber tree and the updated fiber tree based on the virtual DOM.
    This process of comparing elements step by step based on their position in the tree is called Diffing.
    Some elements will be updated, some will be deleted and some will stay the same. All these mutations will then be placed into a list called "the list of effects", which will be used in the next phase.

-------- 11.07 --------
3️⃣ Commit Phase (done by ReactDOM)
  ...
  ⬇️
  List of DOM updates
  ⬇️
  Updated DOM
  ⬇️
  ...

  - React writes to the DOM: insertions, deletions, and updates (list of DOM updates are "flushed" to the DOM). 
  - Committing is synchronous: DOM is updated in one go, it can't be interrupted. This is necessary so that the DOM never shows partial results, ensuring a consistent UI (in sync with state at all times)
  - After the commit phase completes, the workInProgress fiber tree becomes the current tree for the next render cycle.

4️⃣ Browser paint (done by the browser)
  ...
  ⬇️
  Updated UI on the screen

React doesn't touch the DOM. React only renders. It doesn't know where the render result will go.
React can be used on different platforms ("hosts"). For example, we can build native mobile applications for iOS and Android using React Native. Or we can build videos with React using a package called Remotion. Or we can create all sorts of things like Word or PDF documents, Figma designs, and many more using different so-called renderers. (Terrible name, because renderers don't render, they commit the result of render phase).
That's why it's better to call virtual DOM a React Element tree.
And that's why in index.js we import both React and ReactDom

-------- 11.08 --------
How diffing works:
Diffing uses 2 fundamental assumptions (rules):
  1. Two elements of different types will produce different trees.
  2. Elements with a stable key prop stay the same across renders.
Diffing is comparing elements step by step between rwo renders bsed on their position in the tree.

Two situations:
  1. Same position, DIFFERENT element (DOM element / React element)
    - React assumes entire sub-tree is no longer valid
    - Old components are destroyed and removed from DOM including state.
    - Tree might be rebuilt if children stayed the same (state is reset)
  2. Same position, SAME element
    - Element will be kept (as well as child elements), including state.
    - New props / attributes are passed if they changed between renders
    - Sometimes this is not what we want. Then we can use the key prop.

-------- 11.10 --------
Key prop:
- Special prop that we use to tell the diffing algorithm that an element is unique
- Allows React to distinguish between multiple instances of the same component type
- When a key stays the same across renders, the element will be kept in the DOM (even if the position in the tree changes)
  1. Using keys in lists
- When a key changes between renders, the element will be destroyed and a new one will be created (even if the position in the tree is the same as before)
  2. Using keys to reset state

1. Using keys in lists [stable key]
  - If they don't have a key, the same elements if they are moved to a different position, will be removed and recreated in the DOM (bad for performance)
  - If they do have keys, the keys will stay the same, so even if they're in a different position React will keep them in the DOM
2. Key prop to reset state [changing key]
  - We can pass in a different key to force React to recognize an element as a different one. This will reset the state. So when we need to reset state, we need to make sure that we give the element a key and that the key changes across renders.

-------- 11.13 --------
The two types of logic in React components.
1. Render logic
  - Code that lives at the top level of the component function
  - Participates in describing how the component view looks like
  - Executed every time the component renders.
2. Event handler functions 
  - Executed as a consequence of the event that the handler is listening for.
  - Code that actually does things: update state, perform an HTTP request, read an input field, navigate to another page, etc.

Functional programming principles:
- Side effect: dependency on or modification of any data outside the function scope. "Interaction with the outside world". Examples: mutating external variables, HTTP requests, writing to DOM.
    Side effects are not bad! A program can only be useful if it has some interaction with the outside world
- Pure function: a function that has no side effects.
    Does not change any variables outside its scope. Given the same input, a pure function always returns the same output

Rules for render logic:
- Components must be pure when it comes to render logic: given the same props(input), a component instance should always return the same JSX (output)
- Render logic must produce no side effects: no interaction with the "outside world" is allowed. So, in render logic:
  - Do NOT perform network requests (API calls)
  - Do NOT start timers
  - Do NOT directly use the DOM API
  - Do NOT mutate objects of variables outside of the function scope (This is why we can't mutate props!)
  - Do NOT update state (or refs): this will create an infinite loop!
  - Side effects are allowed (and encouraged) in event handler functions! There is also a special hook to register side effects (useEffect)

-------- 11.14 --------
How state updates ar batched:
There is batching of multiple setState calls in event handlers.
If an event handler causes several state updates, they will get batched into just one state update for the entire event handler. So updating multiple pieces of state won't immediately cause a rerender for each update. Only after the state updates are batched then React will trigger one single render and commit. Therefore there are no wasted renders, which is better for performance.  But this can also have surprising results.
Updating state is asynchronous.
So within an event handler even if we change state, it is still "stale" until the component rerenders, so if we try to access it - we'll get the old state.
- Updated state variables are not immediately available after setState call, but only after the re-render
- This also applies when only one state variable is updated
- If we need to update state based on previous update, we use setState with callback (setAnswer (answer=> ... ))

We can opt out of automatic batching by wrapping a state update in ReactDOM.flushSync() (but you'll never need this)

-------- 11.15 --------
If we try to update the state, but it doesn't change (we set it to what it is) then React won't re-render the component.
Whenever we update state based on the current state, we should always use a callback function.
For example:
    // Will only add 1, not 3
    setLikes(likes + 1);
    setLikes(likes + 1);
    setLikes(likes + 1);

    // Will add 3
    setLikes((likes) => likes + 1);
    setLikes((likes) => likes + 1);
    setLikes((likes) => likes + 1);

-------- 11.16 --------
Event propagation and delegation:
1. Capturing phase ( travels from the Document DOM element down to the target element )
2. Target element
3. Bubbling phase ( travels up to the Document DOM element from the target element )

- By default, event handlers listen to events on the target and during the bubbling phase.
- We can prevent bubbling with e.stopPropagation()

Event delegation:
- Handling events for multiple elements centrally in one single parent element
- Better for performance and memory, as it needs only one handler function

1. Add handler to parent
2. Check for target element (e.target)
3. If target is one of the needed elements,handle the event

How React handles events:
React registers all event handlers on the root DOM container (usually div#root, but can be any DOM element). This is where all events are handled.
So this:
  <button
    className="btn"
    onClick={() =setLoading(true)}
  />
Will result in this:
  document
    .querySelector('#root')
    .addEventListener(
    'click',
    () => setLoading(true)
  );
So behind the scenes, React performs event delegation for all events in our applications.

Synthetic events:
- Wrapper around the DOM's native event object.
- It has same interface as native event objects, like stopPropagation() and preventDefault().
- Fixes browser inconsistencies, so that events work in the exact same way in all browsers
- Most synthetic events bubble (including focus, blur, and change), except for scroll

Event handlers in React VS JavaScript:
- Attributes for event handlers are named using camelCase (onClick instead of onclick or click)
- Default behavior can NOT be prevented by returning false (only by using preventDefault())
- Attach "Capture" if you need to handle during capture phase (example: onClickCapture)

-------- 11.17 --------
An analogy:
Framework "All-in-one kit" (Angular / Vue / Svelte)
  + Ease of mind: All ingredients are included
  - No choice: You're stuck with the kit's ingredients
  + Ease of mind: Everything you need to build a complete application is included in the framework ("batteries included")
  - No choice: You're stuck with the framework's tools and conventions (which is not always bad!)

Library "Separate ingredients" (React):
  + Freedom: You can choose the best ingredients
  - Decision fatigue: You need to research and buy all ingredients separately
  + Freedom: You can (or need to) choose multiple 3rd-party libraries to build a complete application
  - Decision fatigue: You need to research, download, learn, and stay up-to-date with multiple external libraries

React has a huge 3rd-party library ecosystem:
1 Routing (for SPAs)
2 HTTP requests
3 Remote state management
4 Global state management
5 Styling
6 Form management
7 Animations/transitions
8 UI components

Opinionated frameworks built on top of React like Next.js, Remix, Gatsby include a lot of the important stuff out of the box.

React frameworks offer many other features: server-side rendering (SSR), static site generation (SSG), better developer experience (DX), etc. Many of these frameworks are full-stack.

-------- 11.18 --------
Practical summary:
A component (function Question()) is like a blueprint for a piece of UI that will eventually exist on the screen. When we "use" a component, React creates a component instance (<Question />), which is like an actual physical manifestation of a component, containing props, state, and more. A component instance, when rendered, will return a React element.

"Rendering" only means calling component functions and calculating what DOM elements need to be inserted, deleted, or updated. It has nothing to do with writing to the DOM. Therefore, each time a component instance is rendered and re-rendered, the function is called again.

Only the initial app render and state updates can cause a render, which happens for the entire application, not just one single component.

When a component instance gets re-rendered, all its children will get re-rendered as well. This doesn't mean that all children will get updated in the DOM, thanks to reconciliation, which checks which elements have actually changed between two renders. But all this re-rendering can still have an impact on performance.

Diffing is how React decides which DOM elements need to be added or modified. If, between renders, a certain React element stays at the same position in the element tree, the corresponding DOM element and component state will stay the same. If the element changed to a different position, or if it's a different element type, the DOM element and state will be destroyed.

Giving elements a key prop allows React to distinguish between multiple component instances. When a key stays the same across renders, the element is kept in the DOM. This is why we need to use keys in lists. When we change the key between renders, the DOM element will be destroyed and rebuilt. We use this as a trick to reset state.

Never declare a new component inside another component! Doing so will re-create the nested component every time the parent component re-renders. React will always see the nested component as new, and therefore reset its state each time the parent state is updated.

The logic that produces JSX output for a component instance ("render logic") is not allowed to produce any side effects: no API calls, no timers, no object or variable mutations, no state updates. Side effects are allowed in event handlers and useEffect.

The DOM is updated in the commit phase, but not by React, but by a "renderer" called ReactDOM. That's why we always need to include both libraries in a React web app project. We can use other renderers to use React on different platforms, for example to build mobile or native apps.

Multiple state updates inside an event handler function are batched, so they happen all at once, causing only one re-render. This means we can not access a state variable immediately after updating it: state updates are asynchronous. Since React 18, batching also happens in timeouts, promises, and native event handlers.

When using events in event handlers, we get access to a synthetic event object, not the browser's native object, so that events work the same way across all browsers. The difference is that most synthetic events bubble, including focus, blur, and change, which do not bubble as native browser events. Only the scroll event does not bubble.

React is a library, not a framework. This means that you can assemble your application using your favorite third-party libraries. The downside is that you need to find and learn all these additional libraries.

-------- 12.02 --------
Component (instance) lifecycle

🐣 Mount / initial render (component is born)
  - Component instance is rendered for the first time
  - Fresh state and props are created
🐔 Re-render (optional) happens when:
  - State changes
  - Props change
  - Parent re-renders
  - Context changes
💀 Unmount (component dies)
  - Component instance is destroyed and removed
  - State and props are destroyed

We can define code to run at these specific points in time.

-------- 12.04 --------
useEffect(() => {}, []) will run after the element mounts.
useEffect will execute after render, so after the component has been painted. 

-------- 12.05 --------
A side effect is basically any "interaction between a React component and the world outside the component". We can also think of a side as "code that actually does something". Examples: Data fetching, setting up subscriptions, setting up timers, manually accessing the DOM, etc.

We need side effects all the time. They make our applications do something. But we don't use them in render logic!
Side effects can be made in:
  Event handlers
    They are triggered by events: onClick, onSubmit, etc.
  Effects (useEffect)
    They are triggered by rendering. Effects allow us to write code that will run at different moments: mount, re-render, or unmount.

When to use event handles and effects?
Event handlers:
  - Executed when the corresponding event happens.
  - Used to react to an event
  - Preferred way of creating side effects!
Effects (useEffect):
  - Executed after the component mounts (initial render), and after subsequent re-renders (according to dependency array)
  - Used to keep a  component synchronized with some external system (i.e API movie data)
Effects have three parts:
  - effect
  - dependency array
  - cleanup function - it will be called before the component rerenders or unmounts.

-------- 12.06 --------
In React's strict mode in development the effects will be called twice, not once.

-------- 12.09 --------
What's the useEffect dependency array?
- By default, effects run after every render. We can prevent that by passing a dependency array
- Without the dependency array, React doesn't know when to run the effect
- Each time one of the dependencies changes, the effect will be executed again
- Every state variable and prop used inside the effect MUST be included in the dependency array (Otherwise, we get a "stale closure")

The mechanics of effects:
- useEffect is like an event listener that is listening for one dependency to change. Whenever a dependency changes, it will execute the effect again.
- Effects react to updates to state and props used inside the effect (the dependencies). So effects are "reactive" (like state updates re-rendering the UI)

useEffect is a synchronization mechanism.

Synchronization and lifecycle:
Dependency ( state or props changes)
      ⬇️                         ⬇️
  Effect is                 Component is
executed again               re-rendered
Effects and component lifecycle are deeply connected.

We can use the dependency array to run effects when the component renders or re-renders.

useEffect(fn, [x , y, z])
  🔁 Effect synchronizes with x, y, and z
  🐣 Runs on mount and re-renders triggered by updating x, y, or z

useEffect(fn, [])
  🔁 Effect synchronizes with NO state/props
  🐣 Runs only on mount (initial render)

useEffect(fn)
  🔁 Effect synchronizes with everything
  🐣 Runs on every render (usually bad!)

When are effects executed?
Mount (initial render)
Commit
Browser paint
Effect ✨ (If an effect sets state, an additional render will be required)

Title (or any dependency) changes
Re-render
Commit
Layout effect (Another type of effect that is very rarely necessary (useLayoutEffect))
Browser paint
Cleanup🧹
Effect ✨

Unmount
Cleanup🧹

-------- 12.10 --------
useEffect(function () {
    console.log("After the initial render");
  }, []);

  useEffect(function () {
    console.log("After every render");
  });

  console.log("During render");

  useEffect(
    function () {
      console.log("After every state update");
    },
    [query]
  );

-------- 12.15 --------
useEffect cleanup function:
- Function that we can return from an effect (optional)
- Runs on two different occasions:
  1) Before the effect is executed again
  2) After a component has unmounted
- Necessary whenever the side effect keeps happening after the component has been re-rendered or unmounted.
- Each effect should do only one thing! Use one useEffect hook for each side effect. This makes  effects easier to clean up/

Component renders -> Execute effect if dependency array includes updated data.
Component unmounts -> Execute cleanup function.

Examples (effect -> potential cleanup):
        HTTP request -> Cancel request
    API subscription -> Cancel subscription
         Start timer -> Stop timer
  Add event listener -> Remove listener

-------- 12.16 --------
When the cleanup function runs after the component has been unmounted and destroyed, it still remembers all the necessary values because of closure. So it remembers all the values that existed when the function was created (and that was before the component was destroyed).

-------- 12.17 --------
Race condition happens when we make a lot of API calls and they end up "racing" each other, anf we don't know which one will arrive first.
If we do HTTP requests, we always need to use cleanup functions to cancel previous request when we make a new one. This will help us avoid race condition and will improve network speed.

-------- 13.02 --------
React hooks:
- Special built-in functions that allow us to "hook" into React internals:
  - Creating and accessing state from Fiber tree
  - Registering side effects in Fiber tree
  - Manual DOM selections
  - Many more ...
- Always start with "use" (useState, useEffect, etc.)
- Enable easy reusing of non-visual logic: we can compose multiple hooks into our own custom hooks
- Give function components the ability to own state and run side effects at different lifecycle points (before v16.8 only available in class components)

Rules of hooks (they are automatically enforced by React's ESlint rules):
1. Only call hooks at the top level
  - Do NOT call hooks inside conditionals, loops, nested functions, or after an early return
  - This is necessary to ensure that hooks are always called in the same order (hooks rely on this)
2. Only call hooks from react functions
  - Only call hooks inside a function component or a custom hook.

-------- 13.04 --------
The initial state like this one
  const [isTop, setIsTop] = useState(imdbRating > 8);
only matter when the component initially renders and won't change during re-renders.

We can change that by using the useEffect hook and call setIsTop(imdbRating > 8) each time imdbRating is changed. But that doesn't make much sense, because we can then simply use derived state like this:
  const isTop = imdbRating > 8;

-------- 13.05 --------
We should pass a function into the useState hook, and not call it.
So we should do this:
  const [watched, setWatched] = useState(function () {
    const storedValue = localStorage.getItem("watched");
    return JSON.parse(storedValue);
  });
not this:
  const [watched, setWatched] = useState(localStorage.getItem("watched"));
Because if we call the function, React will call it each time that the component is rendered, whereas if we pass the function in, React will only call once, when the component first mounts.

-------- 13.06 --------
Creating state:
  - Simple
    const [count, setCount] = useState(23);
  - Based on function (lazy evaluation)
    const [count, setCount] = useState(
      () => localStorage.getItem("count")
    );
    ❗Functions must be pure and accept no arguments. Called only on initial render.
Updating state:
  - Simple
    setCount(1000);
  - Based on current state
    setCount((c) => c + 1);
    ❗Function must be pure ant return next state.
    ❗Make sure to NOT mutate objects or arrays, but to replace them.

-------- 13.08 --------
What are refs?
  const myRef = useRef(23);
We can write to and read from the ref using .current:
  myRef.current = 1000;

- "Box" (object) with a mutable .current property that is persisted across renders ("normal" variables are always reset).
- Two big use cases:
  1) Creating a variable that stays the same between renders (e.g. previous state, setTimeout idm etc.)
  2) Selecting and storing DOM elements
- Refs are for data that id NOT rendered: usually only appear in event handlers or effects, not in JSX (otherwise use state)
- Do NOT read or write ,current in render logic (like state)

State VS Refs
  - Updating Refs won't cause a re-render. So we use state when we want to store data that should rerender the component and Refs for data that should only be remembered by the component over time but never rerender it.
  - Refs are mutable, state isn't.
  Refs update synchronously and the new value can be used immediately after it was updated.

-------- 13.09 --------
Binding ref to a DOM element happens in three steps:
  function Search({ query, setQuery }) {
    const inputEl = useRef(null);   1️⃣ Create Ref hook

    useEffect(function () {
      inputEl.current.focus();    3️⃣ Do something with the DOM element in useEffect hook.
    }, []);

    return (
      <input
        ref={inputEl}   2️⃣ Bind Ref to an actual DOM element
      />
    );
  }

-------- 13.11 --------
In React we can reuse UI with components. We can also reuse logic. If the logic doesn't have any hooks, we can use a regular function. But if it does contain hooks then we need to create a custom hook.

Custom hooks:
- Allow us to reuse non-visual logic in multiple components
- One custom hook should have one purpose, to make it reusable and portable (even across multiple projects).
- Rules of hooks apply to custom hooks too
- Can receive and return any relevant data (usually [] or {})
- Need to use one ore more hooks
- Function name needs to start with use

-------- 13.12 --------
There are two strategies to decide if we want to create a new custom hook:
  - We want to reuse some part of out non-visual logic.
  - We want to extract a huge part of our component out into some custom hook.

-------- 16.03 --------
Usually we use useReducer instead of useState when we have some complex state to manage.
Usually as an action we pass into dispatch() an object like this:
  {
    type: "typeName", 
    payload: someValue (optional)
  }
The huge advantage of using useReducer is that we have all the possible state updates that can happen in our application in one central place. It makes it really easy to understand the entire application.

-------- 16.04 --------
STATE MANAGEMENT WITH useState IS NOT ENOUGH IN CERTAIN SITUATIONS:
1) When components have a lot of state variables and state updates, spread across many event handlers all over the component
2) When multiple state updates need to happen at the same time (as a reaction to the same event, like "starting a game")
3) When updating one piece of state depends on one or multiple other pieces of state
In ALL THESE SITUATIONS, useReducer CAN BE OF GREAT HELP

State with useReducer:
- An alternative way of setting state, ideal for complex state and related pieces of state.
- Stores related pieces of state in a state object.
- useReducer needs reducer: function containing all logic to update state. Decouples state logic from component. (Like setState() with superpowers)
- reducer: pure function (no side effects!) that takes current state and action, and returns the next state.
- action: object that describes how to update state.
- dispatch: function to trigger state updates, by "sending" actions from event handlers to the reducer (instead of setState).

useReducer:
  dispatch -> reducer -> next state -> re-render

useState:
  setState -> next (updated state) -> re-render

-------- 16.16 --------
useState:
  - Ideal for single, independent pieces of state (numbers, strings, single arrays, etc.)
  - Logic to update state is placed directly in event handlers or effects, spread all over one or multiple components.
  - State is updated by calling setState (setter returned form useState)
  - Imperative state updates 
  - Easy to understand and to use

useReducer:
  - Ideal for multiple related pieces of state and complex state (e.g. object with many values and nested objects or arrays)
  - Logic to update state lives in one central place, decoupled from components: the reducer
  - State is updated by dispatching an action to a reducer
  - Declarative state updates: complex state transitions are mapped to actions dispatch({ type: 'startGame' });
  - More difficult to understand and implement

-------- 17.02 --------
Setting up project with Vite:

In terminal go to the folder where we'll create the project.
  > npm create vite@latest
  > project-name
  > React
  > JavaScript

In VScode go to the project folder
  > cd project-name 
  > npm install


In App.jsx delete everything and create new react functional component 

Delete App.css and index.css files.

Delete "import ... css" line from main.jsx

Run
  > npm run dev

In a new terminal install eslint dependencies:
> npm install eslint vite-plugin-eslint eslint-config-react-app --save-dev

In project folder create file .eslintrc.json and write there:
  {
    "extends": "react-app"
  }

In vite.config.js add:
  import eslint from "vite-plugin-eslint";
and change
  plugins: [react()],
to
  plugins: [react(), eslint()],

Save. Project is ready!

-------- 17.03 --------
Routing (client-side routing):
- With routing, we math different URLs to different UI views (React components): routes.
- this enables users to navigate between different applications screens, using the browser URL.
- Keeps the UI in sync with the current browser URL.
- Allows us to build Single-page Applications.

Single-page application:
- Application that is executed entirely on the client (browsers)
- Routes: different URLs correspond to different views (components)
- JavaScript (React) is used to update the page (DOM)
- The page is never reloaded
- Feels like a native app
- Additional data might be loaded from a web API.

User clicks router link -> URL is changed -> DOM is updated: React component corresponding to the new URL is rendered.

-------- 17.05 --------
<Link to="/">Home</Link> 
<NavLink to="/">Home</NavLink> will have class="active" on it if we go to /

-------- 17.07 --------
With CSS modules we can safely use class names and there wont' be any problems if other element in other components has a class with the same name. CSS modules will create a unique class name (like "_nav_afufn_1").
If wanted to create a global class name that won't be changed - we can use 
  :global(.test) {
    background-color: red;
  }
and then the element will simply be className="test" -> class="test" 

-------- 17.10 --------
To create nested routes, we simply place Route elements within each other, like this:
  <Router path="parent" element={<ParentComponent/>}> // /parent
    <Router path="child" element={<ChildComponent/>} /> // /parent/child
  </Router>

In ParentComponent we create a structure like this:
  <ParentComponent>
    <Outlet/>
  </ParentComponent>
or even like this:
  <ParentComponent>
    <OtherComponent>
      <Outlet/>
    </OtherComponent>
  </ParentComponent>

And it will create this structure of elements:
  <ParentComponent>
    <ChildComponent/>
  </ParentComponent>
  
(or this:)
  <ParentComponent>
    <OtherComponent>
      <ChildComponent/>
    </OtherComponent>
  </ParentComponent>