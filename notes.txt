-------- 5.4 --------
React apps are entirely made out of components.
A component has its own data, logic, and appearance (how it works and looks)

-------- 5.5 --------
Nesting components means calling (including) them from the other components. But we never nest function declarations inside each other. We always declare all our components in the top level

-------- 5.6 --------
JSX:
Declarative syntax to describe what components look like and how they work
In practice it means that each component must return one block of JSX.
JSX is is an extension of JavaScript which allows us to combine parts of HTML, CSS and JavaScript all into one block of code.
Each JSX element is converted to a React.createElement function call by Babel. So we could use React without JSX, but that just looks ugly and it's hard to read.

JSX is declarative. It means that we basically describe what UI should look like, based on current data. In contrast, vanilla JS is imperative, and there we manually select DOM elements and traverse the DOM. And we mutate DOM step-by-step.
React is an abstraction away from DOM: we never touch the DOM. Instead, we think of the UI as a reflection of the current data.
Imperative: HOW to do things.
Declarative: WHAT we want.

-------- 5.9 --------
Separation of Concerns
Before the rise of SPAs (single-page applications) we basically had one technology per file. So that was the "Traditional" separation of concerns.
But then JS became more in charge of HTML. Logic and UI are tightly coupled, so why keep them separated? => React components + JSX
So content and logic are tightly coupled together and so it makes sense that they are co-located here. And co-located simply means that things that change together should be located as close as possible together. And in the case of React apps, that means that instead of one technology per file, we have one component per file.

-------- 5.10 --------
WRONG:
<footer class="footer">

RIGHT:
<footer className="footer">

-------- 5.12 --------
Props are used to pass data from parent components to child components (down the component tree).
With props, parent components control how child components look and work.
Anything can be passed as props: we can pass single values, arrays, objects, functions and even other React components.
Component's data consists of props and state. State is basically internal component data that can be updated by the component's logic (by the component itself). And props is data coming from the outside, it can only be updated by the parent component.
Props are immutable. They're read only.
If you need to mutate props, you actually need state.
That's because mutating props would affect parent, creating side effects.
And React is all about pure functions without side-effects.
In general in React a component should never mutate any data that we write outside of its function scope.
React uses one-way data flow. So data can flow from parents to children, but never the opposite way.

-------- 5.14 --------
JSX works essentially just like HTML. However, we can enter a JavaScript mode by using curly braces anywhere in the markup where a value like text or an attribute is expected.
We can place JS expressions inside {}. For example: reference variables, arrays, objects, [].map(), ternary operator.
Statements are not allowed (if / else, for, switch).
JSX produces a JS expression. 
We can place other pieces of JSX inside {}.
We can write JSX anywhere inside a component (in if / else, assign to variables, pass it into functions).
JSX can only have one root element. If you need more, use <React.Fragment> (see below, in 5.21)
DIFFERENCES BETWEEN JSX AND SHTML
- className instead of HTML's class
- htmlFor instead of HTML's for
- Every tag needs to be closed. Examples: <img /> or <br />
- All event handlers and other properties need to be camelCased. Examples: onClick or onMouseOver
- Exception: aria-* and data-* are written with dashes like in HTML
- CSS inline styles are written like this: {{<style>}} (to reference a variable, and then an object)
- CSS property names are also camelCased
- Comments need to be in {} (because they are JS)

-------- 5.20 --------
function Order({ closeHour, openHour }) {
  return (
      <p>
        We're open from {openHour}:00 to {closeHour}:00. Come visit us or order
        online.
      </p>
  );
}

is basically a short version of 

function Order(props) {
  return (
      <p>
        We're open from {props.openHour}:00 to {props.closeHour}:00. Come visit us or order
        online.
      </p>
  );
}
It uses destructuring.

-------- 5.21 --------
React Fragment is this element: <></> or, the longer version, that allows to include a key: <React.Fragment key="somKeyHere"></React.Fragment>. You can wrap several elements into it and then the function will return several html nodes as if they have no wrapper at all. So basically it enables us to return several elements from a component.

-------- 6.3 --------
onClick={() => alert("previous")}
Here inside of {} should be a function, not a function call. Otherwise it'll be called immediately as the page loads.
So, for example, it should be like this: onClick={handlePrevious} or this: onClick={() => alert("next")}
Neither this: onClick={handlePrevious()} nor this: onClick={alert("next")}

Event handler functions can be written inside of a function declaring the component, like this:
export default function App() {
  function handlePrevious() {}

  return (...);
}

-------- 6.4 --------
So state is basically data that a component can hold over time, and we use it for information that the component needs to remember throughout its lifecycle. Therefore, we can think of state as being the memory of a component.
Some examples: notification count, text content of an input field or the active tab in a tabbed component. It can also be a bit more complex data, for example, the content of a shopping cart.
"State variable" or a "piece of state" is a single variable in a component (component state).
And "state" is like the entire condition of the component at a certain point in time.
So, state === all pieces of state together.

Updating component state triggers React to re-render the component, so to create a new Component View.
Component View is basically just the component visually rendered on the screen.
State allows developers to: 
Update the component's view by rerendering the component.
Persist local variables between multiple renders and rerenders.

-------- 6.5 --------
const [step, setStep] = useState(1);
useState returns an array with two things:
[0] step - is a variable
[1] setStep - function to update step
1 - default value that is assigned to [0] step

useState function is a hook. Hooks start with "use" keyword.
We can only call hooks like use state on the top level of the function.

We should really only update state using setter function. So not manually.

-------- 6.7 --------
A component is re-rendered when its state is updated.
We change state -> React re-renders component -> View will be replace with a new one.
So to update the view we need to update the state.
React is called this way because it reacts to state changes by re-rendering the UI.

-------- 6.10 --------
WRONG and won't work twice:
setStep(step + 1);
setStep(step + 1);

RIGHT, works as expected:
setStep((s) => s + 1);
setStep((s) => s + 1);

We need to do this when we update the state by using the current value of the state.

-------- 6.11 --------
Each component has and manages its own state, no matter how many times we render the same component. So, for example, if we have several <Item /><Item /><Item /> on the page, each of them will have its own state that won't affect the state of others. The entire UI is always a representation of all the current states in all components. A React application is fundamentally all about changing state over time and of course also correctly displaying that state at all times.

PRACTICAL GUIDELINES ABOUT STATE

Use a state variable for any data that the component should keep track of ("remember") over
time. This is data that will change at some point. In Vanilla JS, that's a let variable, or an [] or {}

Whenever you want something in the component to be dynamic, create a piece of state related
to that "thing", and update the state when the "thing" should change (aka "be dynamic")
Example: A modal window can be open or closed. So we create a state variable
isOpen that tracks whether the modal is open or not. On isOpen = true we
display the window, on isOpen = false we hide it.

If you want to change the way a component looks, or the data it displays, update its state.
This usually happens in an event handler function.

When building a component, imagine its view as a reflection of state changing over time

For data that should not trigger component re-renders, don't use state. Use a regular variable
instead. This is a common beginner mistake.

-------- 6.19 --------
State is internal data. So data that is owned by the component in which it is declared. State can be thought of as the components memory because it can hold data over time. State can be updated by the component itself. This will then cause the component to be rerendered by react.


Props is external data. So data that is owned by the parent component and you can think of props as function parameters, as a communication channel between parent and child components where parents can pass data into children. When the child component receives new updated props that will actually also cause the component to rerender.

So in conclusion, whenever a piece of state is passed as a prop, when that state updates, both components are re-rendered.

STATE                                   PROPS

Internal data, owned by          External data, owned by
component                        parent component

Component "memory"               Similar to function                       
                                 parameters

Can be updated by the            Read-only
component itself

Updating state causes            Receiving new props causes
component to re-render           component to re-render.
                                 Usually when the parent's
                                 state has been updated


Used to make components          Used by parent to configure
interactive                      child component ("settings")

-------- 7.3 --------
State management: Deciding when to create pieces of
state, what types of state are necessary, where to place
each piece of state, and how data flows through the app.

LOCAL STATE

- State needed only by one or few components
- State that is defined in a component and only
that component and child components have
access to it (by passing via props)

GLOBAL STATE

- State that many components might need
- Shared state that is accessible to every
component in the entire application

-------- 7.5 --------
We can call the technique of passing down a setter function "child to parent communication" or also "inverse data flow". Inverse, because usually data only flows down. But here we have a trick that allows us to basically have the data flowing up as well.

-------- 8.6 --------
The basic attachment of input:
function Input() {
  const [name, setName] = useState();
  
  return (
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
  );
}

-------- 10.3 --------
A component that is too large does too many things and has too many responsibilities. It receives too many props (> 10). The're hard to reuse. The code is very complex.
Components that are too small create a confusing codebase with hundreds of mini-components. The codebase would be too abstracted.
The 4 criteria for splitting a UI into components:
  1. Logical separation of content/layout
  2. Reusability
  3. Responsibilities / complexity
  4. Personal coding style

When to create a new component?
Start with a big component and split it into smaller ones when it becomes necessary.
You might need a new component if:
- The component contains pieces of content or layout that don't belong together.
- It's possible to reuse part of the component
- You want / need to reuse part of a component
- The component is doing too many different things
- The component relies on too many props
- The component has too many pieces of state and/or effects?
- The code, including JSX, is too complex/confusing
- You prefer smaller functions / components

! Be aware that creating a new component creates a new abstraction. Abstractions have a cost, because more abstractions require more mental  energy to switch back and forth between components. So try not to create new components too early.
! Name a component according to what it does or what it displays. Don't be afraid of using long component names
! Never declare a new component inside another component!
! Co-locate related components inside the same file. Don't separate components into different files too early
! It's completely normal that an app has components of many different sizes, including very small and huge ones

The smaller components are - the more reusable they are.

-------- 10.5 --------
Most of the components in React fall into one of three categories:
- Stateless / presentational components
    These don't have any state. They get some props and then simply present the data & other content. The're usually small and reusable.
- Stateful components
    They have state. Can be reusable.
- Structural components
    "Pages", "layouts" or "screens" of the app. They're the result of composition. They can be huge and non-reusable (but they don't have to).

-------- 10.7 --------
>> Using a component:
    function Modal() {
      return (
        <div className="modal">
          <Success />
        </div>
      )
    }

    function Success() {
      return <p>Well done !</p>;
    }

>> Component composition: 
    function Modal({ children }) {
      return (
        <div className="modal">
          {children}
        </div>
      )
    }

    function Success() {
      return <p>Well done !< /p>;
    }
  It is used like this: 
    <Modal>
      <Success />
    </Modal>

So component composition is combining different components using the children prop (or explicitly defined props)
With component composition, we can:
1. Create highly reusable and flexible components
2. Fix prop drilling (great for layouts)

-------- 10.10 --------
Implicitly passing in the component:
  <Box>
    <MovieList movies={movies} />
  </Box>

  function Box({ children }) { 
    return <div>{ children }</div>
  }

OR

Explicitly passing in the component:

  <Box element={<MovieList movies={movies} />} />
  function Box({ element }) {
    return <div>{ element }</div>
  }

They both work the same, but with explicit passing you can give the element different names and place them in different places of your code.

-------- 10.14 --------
Every component is created by someone and consumed by someone.
In a way, we can think of components' props as public API of the component

Having too little props:
 - Not flexible enough
 - Might not be useful

Having too many props:
 - Too hard to use
 - Exposing too much complexity
 - Hard-to-write code
 - If you have to do this, provide good default values

We need to find the right balance between too little and too many props, that works for both the consumer and the creator.

-------- 11.03 --------
Component:
  - Description of a piece of UI
  - A component is a function that returns React elements (element tree), usually written as JSX
  - "Blueprint" or "Template"

Component instance:
  - Instances are created when we "use" components
  - React internally calls the component as many times as needed
  - Actual "physical" manifestation of a component
  - Has its own state and props
  - Has a lifecycle (can "be born", "live", and "die")
  - Returns a React element

React element:
  - JSX is converted to React.createElement() function calls
  - A React element is the result of these function calls
  - Basically a big immutable JS object that React keeps in memory
  - Information necessary to create DOM elements
  - Then it's inserted to DOM as a DOM Element (HTML)

DOM Element (HTML)
  - Actual visual representation of the component instance in the browser

-------- 11.04 --------
Symbols (JS primitive) cannot be transmitted via JSON. So React uses them in React elements in order to protect us from getting a fake React element from a malware API.
In theory, we can call a component directly, like this:
  SomeComponent()
instead of this:
  <SomeComponent />
But then React won't see it as a component instance, but as a raw React element. The sate will go to the parent element, so basically it will not work as expected. So never do this.

-------- 11.05 --------
Component -> Component instance -> React Element -> DOM Element (HTML) -> User interface on the screen.

1️⃣ Render is triggered (by updating state somewhere)
 ⬇️
2️⃣ Render Phase (React calls component functions and figures out how DOM should be updated)
 ⬇️
3️⃣ Commit Phase (React actually writes to the DOM, updating, inserting, and deleting elements)
 ⬇️
4️⃣ Browser paint

In React, rendering is NOT updating the DOM or displaying elements on the screen. Rendering only happens internally inside React, it does not produce visual changes.
What we traditionally call rendering happens in two phases in React: render + commit phase.

1️⃣ Render is triggered
  THE TWO SITUATIONS THAT TRIGGER RENDERS:
  1. Initial render of the application
  2. State is updated in one or more component instances (re-render)

  - The render process is triggered for the entire application. But that doesn't meant that everything gets recreated in the DOM. It just means that the process of calling the component functions starts.
  - In practice, it looks like React only re-renders the component where the state update happens, but that's not how it works behind the scenes
  - Renders are not triggered immediately, but scheduled for when the JS engine has some "free time". There is also batching of multiple setState calls in event handlers

-------- 11.06 --------
2️⃣ Render Phase (done by React)
  Component instances that triggered re-render
      At the beginning of the render phase, React will go through the entire component tree, take all the component instances that triggered a re-render and actually render them, i.e call the corresponding component functions that we've written in our code.
  ⬇️
  React Elements
      This creates updated React elements which all together make up the so-called "new virtual DOM". It contains the old elements, the updated element and the updated children of the updated element.
  ⬇️
  New Virtual DOM
  ⬇️
  Reconciliation + Diffing with the current so-called Fiber tree as it exists before the state update.
  ⬇️
  Updated Fiber tree
  ⬇️
  List of DOM updates
  ⬇️
  ...

  The Virtual DOM:
    It is a tree of all React elements created from all instances in the component tree. It's cheap and fast to create multiple trees. Basically it's just an object with information about what to create.
    1) Initial render
      Component tree -> React element tree
    2) Re-renders
      Rendering a component will cause all of its child components to be rendered as well (no matter if props changed or not). It is necessary because React doesn't know whether children will be affected.

  React reconciler is called "Fiber".

  What is reconciliation and why do we need it?
  We need it because:
  - Updating the entire DOM is inefficient and wasteful:
    1. Writing to the DOM is (relatively) slow.
    2. Usually only a small part of the DOM needs to be updated.
  - React reuses as much of the existing DOM as possible
    It uses Reconciliation: Deciding which DOM elements actually need to be inserted, deleted, or updated, in order to reflect the latest state changes.

  Reconciliation is processed by a reconciler, and we can say that the reconciler really is the engine of React, the heart of React.

  The reconciler: Fiber.
    The Fiber takes the whole React element tree (virtual DOM) and based on it builds a fiber tree.
    Fiber tree is an internal tree that has a "fiber" for each component instance and DOM element.
    Fibers are NOT re-created on every render. Fiber tree is never destroyed. Instead, it's a mutable data structure. It is created during the initial render and then it mutates over and over again.
    So fibers ("units of work") keep track of things like current component state, props, side effects, used hooks, etc. It also contains queue of work to do.
    Fiber tree doesn't have the usual parent-children structure. It has a structure of a linked list, where each first child has a link to its parent and all the other children that have a link to their previous sibling.
    Fiber tree contains both React components and DOM elements, so it is a complete representation of the entire DOM structure.
    Work can be done asynchronously, so rendering process can be split into chinks, tasks can be prioritized, and work can be paused, reused, or thrown away. 
      - It enables concurrent features like Suspense or transitions. 
      - Long renders won't block JS engine.
  Reconciliation in action.
    Whenever reconciliation needs to happen, fiber walks through the entire tree step by step and analyzes what needs to change between the current fiber tree and the updated fiber tree based on the virtual DOM.
    This process of comparing elements step by step based on their position in the tree is called Diffing.
    Some elements will be updated, some will be deleted and some will stay the same. All these mutations will then be placed into a list called "the list of effects", which will be used in the next phase.

-------- 11.07 --------
3️⃣ Commit Phase (done by ReactDOM)
  ...
  ⬇️
  List of DOM updates
  ⬇️
  Updated DOM
  ⬇️
  ...

  - React writes to the DOM: insertions, deletions, and updates (list of DOM updates are "flushed" to the DOM). 
  - Committing is synchronous: DOM is updated in one go, it can't be interrupted. This is necessary so that the DOM never shows partial results, ensuring a consistent UI (in sync with state at all times)
  - After the commit phase completes, the workInProgress fiber tree becomes the current tree for the next render cycle.

4️⃣ Browser paint (done by the browser)
  ...
  ⬇️
  Updated UI on the screen

React doesn't touch the DOM. React only renders. It doesn't know where the render result will go.
React can be used on different platforms ("hosts"). For example, we can build native mobile applications for iOS and Android using React Native. Or we can build videos with React using a package called Remotion. Or we can create all sorts of things like Word or PDF documents, Figma designs, and many more using different so-called renderers. (Terrible name, because renderers don't render, they commit the result of render phase).
That's why it's better to call virtual DOM a React Element tree.
And that's why in index.js we import both React and ReactDom

-------- 11.08 --------
How diffing works:
Diffing uses 2 fundamental assumptions (rules):
  1. Two elements of different types will produce different trees.
  2. Elements with a stable key prop stay the same across renders.
Diffing is comparing elements step by step between rwo renders bsed on their position in the tree.

Two situations:
  1. Same position, DIFFERENT element (DOM element / React element)
    - React assumes entire sub-tree is no longer valid
    - Old components are destroyed and removed from DOM including state.
    - Tree might be rebuilt if children stayed the same (state is reset)
  2. Same position, SAME element
    - Element will be kept (as well as child elements), including state.
    - New props / attributes are passed if they changed between renders
    - Sometimes this is not what we want. Then we can use the key prop.

-------- 11.10 --------
Key prop:
- Special prop that we use to tell the diffing algorithm that an element is unique
- Allows React to distinguish between multiple instances of the same component type
- When a key stays the same across renders, the element will be kept in the DOM (even if the position in the tree changes)
  1. Using keys in lists
- When a key changes between renders, the element will be destroyed and a new one will be created (even if the position in the tree is the same as before)
  2. Using keys to reset state

1. Using keys in lists [stable key]
  - If they don't have a key, the same elements if they are moved to a different position, will be removed and recreated in the DOM (bad for performance)
  - If they do have keys, the keys will stay the same, so even if they're in a different position React will keep them in the DOM
2. Key prop to reset state [changing key]
  - We can pass in a different key to force React to recognize an element as a different one. This will reset the state. So when we need to reset state, we need to make sure that we give the element a key and that the key changes across renders.