-------- 5.4 --------
React apps are entirely made out of components.
A component has its own data, logic, and appearance (how it works and looks)

-------- 5.5 --------
Nesting components means calling (including) them from the other components. But we never nest function declarations inside each other. We always declare all our components in the top level

-------- 5.6 --------
JSX:
Declarative syntax to describe what components look like and how they work
In practice it means that each component must return one block of JSX.
JSX is is an extension of JavaScript which allows us to combine parts of HTML, CSS and JavaScript all into one block of code.
Each JSX element is converted to a React.createElement function call by Babel. So we could use React without JSX, but that just looks ugly and it's hard to read.

JSX is declarative. It means that we basically describe what UI should look like, based on current data. In contrast, vanilla JS is imperative, and there we manually select DOM elements and traverse the DOM. And we mutate DOM step-by-step.
React is an abstraction away from DOM: we never touch the DOM. Instead, we think of the UI as a reflection of the current data.
Imperative: HOW to do things.
Declarative: WHAT we want.

-------- 5.9 --------
Separation of Concerns
Before the rise of SPAs (single-page applications) we basically had one technology per file. So that was the "Traditional" separation of concerns.
But then JS became more in charge of HTML. Logic and UI are tightly coupled, so why keep them separated? => React components + JSX
So content and logic are tightly coupled together and so it makes sense that they are co-located here. And co-located simply means that things that change together should be located as close as possible together. And in the case of React apps, that means that instead of one technology per file, we have one component per file.

-------- 5.10 --------
WRONG:
<footer class="footer">

RIGHT:
<footer className="footer">

-------- 5.12 --------
Props are used to pass data from parent components to child components (down the component tree).
With props, parent components control how child components look and work.
Anything can be passed as props: we can pass single values, arrays, objects, functions and even other React components.
Component's data consists of props and state. State is basically internal component data that can be updated by the component's logic (by the component itself). And props is data coming from the outside, it can only be updated by the parent component.
Props are immutable. They're read only.
If you need to mutate props, you actually need state.
That's because mutating props would affect parent, creating side effects.
And React is all about pure functions without side-effects.
In general in React a component should never mutate any data that we write outside of its function scope.
React uses one-way data flow. So data can flow from parents to children, but never the opposite way.

-------- 5.14 --------
JSX works essentially just like HTML. However, we can enter a JavaScript mode by using curly braces anywhere in the markup where a value like text or an attribute is expected.
We can place JS expressions inside {}. For example: reference variables, arrays, objects, [].map(), ternary operator.
Statements are not allowed (if / else, for, switch).
JSX produces a JS expression. 
We can place other pieces of JSX inside {}.
We can write JSX anywhere inside a component (in if / else, assign to variables, pass it into functions).
JSX can only have one root element. If you need more, use <React.Fragment> (see below, in 5.21)
DIFFERENCES BETWEEN JSX AND SHTML
- className instead of HTML's class
- htmlFor instead of HTML's for
- Every tag needs to be closed. Examples: <img /> or <br />
- All event handlers and other properties need to be camelCased. Examples: onClick or onMouseOver
- Exception: aria-* and data-* are written with dashes like in HTML
- CSS inline styles are written like this: {{<style>}} (to reference a variable, and then an object)
- CSS property names are also camelCased
- Comments need to be in {} (because they are JS)

-------- 5.20 --------
function Order({ closeHour, openHour }) {
  return (
      <p>
        We're open from {openHour}:00 to {closeHour}:00. Come visit us or order
        online.
      </p>
  );
}

is basically a short version of 

function Order(props) {
  return (
      <p>
        We're open from {props.openHour}:00 to {props.closeHour}:00. Come visit us or order
        online.
      </p>
  );
}
It uses destructuring.

-------- 5.21 --------
React Fragment is this element: <></> or, the longer version, that allows to include a key: <React.Fragment key="somKeyHere"></React.Fragment>. You can wrap several elements into it and then the function will return several html nodes as if they have no wrapper at all. So basically it enables us to return several elements from a component.

-------- 6.3 --------
onClick={() => alert("previous")}
Here inside of {} should be a function, not a function call. Otherwise it'll be called immediately as the page loads.
So, for example, it should be like this: onClick={handlePrevious} or this: onClick={() => alert("next")}
Neither this: onClick={handlePrevious()} nor this: onClick={alert("next")}

Event handler functions can be written inside of a function declaring the component, like this:
export default function App() {
  function handlePrevious() {}

  return (...);
}

-------- 6.4 --------
So state is basically data that a component can hold over time, and we use it for information that the component needs to remember throughout its lifecycle. Therefore, we can think of state as being the memory of a component.
Some examples: notification count, text content of an input field or the active tab in a tabbed component. It can also be a bit more complex data, for example, the content of a shopping cart.
"State variable" or a "piece of state" is a single variable in a component (component state).
And "state" is like the entire condition of the component at a certain point in time.
So, state === all pieces of state together.

Updating component state triggers React to re-render the component, so to create a new Component View.
Component View is basically just the component visually rendered on the screen.
State allows developers to: 
Update the component's view by rerendering the component.
Persist local variables between multiple renders and rerenders.

-------- 6.5 --------
const [step, setStep] = useState(1);
useState returns an array with two things:
[0] step - is a variable
[1] setStep - function to update step
1 - default value that is assigned to [0] step

useState function is a hook. Hooks start with "use" keyword.
We can only call hooks like use state on the top level of the function.

We should really only update state using setter function. So not manually.

-------- 6.7 --------
A component is re-rendered when its state is updated.
We change state -> React re-renders component -> View will be replace with a new one.
So to update the view we need to update the state.
React is called this way because it reacts to state changes by re-rendering the UI.

-------- 6.10 --------
WRONG and won't work twice:
setStep(step + 1);
setStep(step + 1);

RIGHT, works as expected:
setStep((s) => s + 1);
setStep((s) => s + 1);

We need to do this when we update the state by using the current value of the state.

-------- 6.11 --------
Each component has and manages its own state, no matter how many times we render the same component. So, for example, if we have several <Item /><Item /><Item /> on the page, each of them will have its own state that won't affect the state of others. The entire UI is always a representation of all the current states in all components. A React application is fundamentally all about changing state over time and of course also correctly displaying that state at all times.

PRACTICAL GUIDELINES ABOUT STATE

Use a state variable for any data that the component should keep track of ("remember") over
time. This is data that will change at some point. In Vanilla JS, that's a let variable, or an [] or {}

Whenever you want something in the component to be dynamic, create a piece of state related
to that "thing", and update the state when the "thing" should change (aka "be dynamic")
Example: A modal window can be open or closed. So we create a state variable
isOpen that tracks whether the modal is open or not. On isOpen = true we
display the window, on isOpen = false we hide it.

If you want to change the way a component looks, or the data it displays, update its state.
This usually happens in an event handler function.

When building a component, imagine its view as a reflection of state changing over time

For data that should not trigger component re-renders, don't use state. Use a regular variable
instead. This is a common beginner mistake.

-------- 6.19 --------
State is internal data. So data that is owned by the component in which it is declared. State can be thought of as the components memory because it can hold data over time. State can be updated by the component itself. This will then cause the component to be rerendered by react.


Props is external data. So data that is owned by the parent component and you can think of props as function parameters, as a communication channel between parent and child components where parents can pass data into children. When the child component receives new updated props that will actually also cause the component to rerender.

So in conclusion, whenever a piece of state is passed as a prop, when that state updates, both components are re-rendered.

STATE                                   PROPS

Internal data, owned by          External data, owned by
component                        parent component

Component "memory"               Similar to function                       
                                 parameters

Can be updated by the            Read-only
component itself

Updating state causes            Receiving new props causes
component to re-render           component to re-render.
                                 Usually when the parent's
                                 state has been updated


Used to make components          Used by parent to configure
interactive                      child component ("settings")

-------- 7.3 --------
State management: Deciding when to create pieces of
state, what types of state are necessary, where to place
each piece of state, and how data flows through the app.

LOCAL STATE

- State needed only by one or few components
- State that is defined in a component and only
that component and child components have
access to it (by passing via props)

GLOBAL STATE

- State that many components might need
- Shared state that is accessible to every
component in the entire application

-------- 7.5 --------
We can call the technique of passing down a setter function "child to parent communication" or also "inverse data flow". Inverse, because usually data only flows down. But here we have a trick that allows us to basically have the data flowing up as well.

-------- 8.6 --------
The basic attachment of input:
function Input() {
  const [name, setName] = useState();
  
  return (
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
  );
}